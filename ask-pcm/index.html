<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="McLaren Labs of San Francisco">
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Alsa Sound Kit - PCM - MSK</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/console.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/objc.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/smalltalk.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">MSK</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Developer <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../setup/" class="dropdown-item">GNUstep Setup</a>
</li>
                                    
<li>
    <a href="../ask-midi/" class="dropdown-item">Alsa Sound Kit - MIDI</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Alsa Sound Kit - PCM</a>
</li>
                                    
<li>
    <a href="../msk-over/" class="dropdown-item">McLaren Synth Kit - Overview</a>
</li>
                                    
<li>
    <a href="../msk-metronome/" class="dropdown-item">McLaren Synth Kit - Metronome</a>
</li>
                                    
<li>
    <a href="../msk-pattern/" class="dropdown-item">McLaren Synth Kit - Patterns</a>
</li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../conclusion/" class="nav-link">Conclusion</a>
                            </li>
                            <li class="navitem">
                                <a href="../toc/" class="nav-link">Table Of Contents</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../ask-midi/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../msk-over/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/mclarenlabs/libs-mclaren-alpha/" class="nav-link"><i class="fa fa-github"></i> GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#alsa-sound-kit-pcm" class="nav-link">Alsa Sound Kit - PCM</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#alsa-pcm-system-overview" class="nav-link">ALSA PCM System Overview</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#pulse-and-jack" class="nav-link">Pulse and JACK</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#ask-pcm" class="nav-link">ASK Pcm</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#configure-a-pcm" class="nav-link">Configure a PCM</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#set-the-callbacks" class="nav-link">Set the Callbacks</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#start-the-audio-thread" class="nav-link">Start the Audio Thread</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#experiment-with-alsa-devices" class="nav-link">Experiment with ALSA Devices</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#listing-available-pcms" class="nav-link">Listing Available PCMs</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#summary" class="nav-link">Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="alsa-sound-kit-pcm">Alsa Sound Kit - PCM</h1>
<p>The Alsa Sound Kit (ASK) provides Objective-C wrappers around ALSA MIDI devices and ALSA PCM (sound) devices.  This chapter describes how sound devices are configured and how sounds are played or captured. </p>
<h2 id="alsa-pcm-system-overview">ALSA PCM System Overview</h2>
<p>The Advance Linux Sound Architecture (ALSA) library calls a device that can translate continuous sound waves into a series of samples a "PCM" (PCM stands for Pulse Code Modulation).  ALSA PCM devices can PLAY and CAPTURE sounds.</p>
<p>In your system, a sound capability is provided by a "card."  These days, a sound card is usually integrated directly into your laptop motherboard.  When you plug a USB audio device into your system, that will appear as a card too.  A card can have one or more devices.  Some of the devices can play or capture audio, and there can be devices for MIDI or other functions too.  For our purposes here, we'll be focusing just on the devices that play or capture audio.</p>
<p>On a Linux computer, you can list sound devices using the <code>aplay</code> command.  This command can also play audio samples.  Try it out like this.</p>
<pre><code class="language-console">$ aplay /usr/share/sounds/alsa/Front_Center.wav 
Playing WAVE '/usr/share/sounds/alsa/Front_Center.wav' : Signed 16 bit Little Endian, Rate 48000 Hz, Mono
</code></pre>
<p>If all goes well, you'll hear a sound saying "Front. Center." and you'll see the output above.</p>
<p>To list the audio cards and devices in your system use <code>aplay -l</code>.  On our laptop at McLaren Labs, it produces the following output.</p>
<pre><code class="language-console">$ aplay -l
**** List of PLAYBACK Hardware Devices ****
card 0: HDMI [HDA Intel HDMI], device 3: HDMI 0 [HDMI 0]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 0: HDMI [HDA Intel HDMI], device 7: HDMI 1 [HDMI 1]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 0: HDMI [HDA Intel HDMI], device 8: HDMI 2 [HDMI 2]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 0: HDMI [HDA Intel HDMI], device 9: HDMI 3 [HDMI 3]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 0: HDMI [HDA Intel HDMI], device 10: HDMI 4 [HDMI 4]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 1: PCH [HDA Intel PCH], device 0: CS4208 Analog [CS4208 Analog]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 1: PCH [HDA Intel PCH], device 1: CS4208 Digital [CS4208 Digital]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
</code></pre>
<p>We can see that there are two "cards" in the system.  Card 0 is dedicated to HDMI output.  Card 1 provides audio output to the speakers and headphones of the laptop and can capture from the microphone.</p>
<blockquote>
<p>Aside: In ALSA, a hardware card/device combo is referred to with name in a special format.</p>
<p><code>"hw:%d,%d"</code></p>
<p>So to refer to our built-in audio card, we would use "hw:1,0".</p>
</blockquote>
<p>If you plug a USB device into your computer, you can see a new "card" appear.  Here, we've plugged in a USB playback and capture device.  Using <code>aplay -l</code>, we see the following new device.</p>
<pre><code class="language-console">$ aplay -l
...
card 3: Device [USB Audio Device], device 0: USB Audio [USB Audio]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
</code></pre>
<p>Each of these sound devices has a "device name" and a "display name" in the Alsa Sound Kit.  For these hardward devices, the "device name" is its card/device combo referred to in a special format: <code>"hw:%d,%d"</code>.  The "display name" of the device is the more human-friendly string at the end of the line in square brackets.  In our system, we have the following pairs.</p>
<table>
<thead>
<tr>
<th>Device Name</th>
<th>Display Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>hw:0,0</td>
<td>HDMI 0</td>
</tr>
<tr>
<td>hw:0,1</td>
<td>HDMI 0</td>
</tr>
<tr>
<td>hw:0,2</td>
<td>HDMI 0</td>
</tr>
<tr>
<td>hw:0,3</td>
<td>HDMI 0</td>
</tr>
<tr>
<td>hw:1,0</td>
<td>CS4208 Analog</td>
</tr>
<tr>
<td>hw:1,1</td>
<td>CS4208 Digital</td>
</tr>
<tr>
<td>hw:3,0</td>
<td>USB Audio</td>
</tr>
</tbody>
</table>
<h3 id="other-pseudo-devices">Other (pseudo) Devices</h3>
<p>ALSA provides a plug-in architecture that allows for virtual PCM devices.   Some of these devices can be used to playback or capture sounds, others process or modify PCM (waveform) buffers.  You can see a list of them using <code>aplay -L</code>.</p>
<p>The output of this command does not make it apparent which of these devices can be used for playback or capture: that information is embedded in the ALSA system  and is available through C functions.  Fortunately, the Alsa Sound Kit is aware of how to find these.  For these pseudo-devices, their "device name" (the name used in code) is the same as their "display name."</p>
<p>On our system, the following pseudo-devices are available.</p>
<table>
<thead>
<tr>
<th>Device Name</th>
<th>Display Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>default</td>
<td>default</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>pulse</td>
<td>pulse</td>
</tr>
</tbody>
</table>
<p>A Linux Audio system is usually configured with the "default" and "null" pseudo-devices available.  The "default" device corresponds to whatever is selected as the desktop speaker and microphone in a standard setup.  The "null" device is a special device that drops all samples sent to it, and produces "zeroes" when used as a capture device.</p>
<p>Our system alsa has a pseudo-device for "pulse" - the "Pulse Sound Server".</p>
<h2 id="pulse-and-jack">Pulse and JACK</h2>
<p>Pulse and JACK are both audio sound servers.  Each of these "takes over" a hardware device and provides a virtual interface for application programs to use.</p>
<p>JACK is used in high-performance audio environments and provides an "audio-bus" abstraction for sharing low-latency audio streams between applications.  JACK is not configured by default on many Linux systems, but is easy to install.  Programs that make the optimal use of JACK use the JACK API directly rather than ALSA.  (Note: JACK can also provide access via an ALSA Virtual PCM.)</p>
<p>Pulse is used on the desktop to multiplex the one selected hardware audio device between all of the applications on the desktop.  ALSA applications that open the "default" or "pulse" audio device on a Pulse-enabled system actually open a port to the Pulse sound server, which then mixes its sound output with other applications that are producing sounds at the same time.</p>
<p>Pulse makes applications more friendly on the desktop, but adds a little bit of latency.  If your target application is a realtime synthesizer, for instance, it is advisable to bypass Pulse and access a hardware (non-virtual) device directly.</p>
<blockquote>
<p>Note: Pulse and pasuspender</p>
<p>When an audio device is in use by Pulse, it is "busy" for other applications.  If you need to temporarily pause Pulse
and make it release a device, use the <code>pasuspender</code> command.</p>
<p>$ pasuspender -- pgm args ...</p>
</blockquote>
<h2 id="ask-pcm">ASK Pcm</h2>
<p>An <code>ASKPcm</code> object is the Alsa Sound Kit wrapper for an ALSA Pcm handle.  The <code>ASKPcm</code> interface provides methods for:</p>
<ul>
<li>opening a PCM</li>
<li>querying its capabilities</li>
<li>configuring its parameters</li>
<li>registering audio callback blocks</li>
<li>starting and stopping the audio thread</li>
</ul>
<p>This section will describe how to open and configure an audio device, and how to play a sound.</p>
<h3 id="open-a-pcm">Open a PCM</h3>
<p>The initializer for an <code>ASKPcm</code> opens the named ALSA device for playback or capture.  The ALSA "device name" should be specified.</p>
<pre><code class="language-objc">  NSError *error;
  ASKPcm *pcm = [[ASKPcm alloc] initWithName:@&quot;default&quot;
                                      stream:SND_PCM_STREAM_PLAYBACK // or SND_PCM_STREAM_CAPTURE
                                       error:&amp;error];
</code></pre>
<p>If the PCM cannot be opened because then name doesn't exist, or because it is in use by another program, or because it is not usable for the "stream" specified there will be an error returned.</p>
<h2 id="configure-a-pcm">Configure a PCM</h2>
<p>Once a PCM is opened, it must be configured for use.  This involves setting two sets of parameters: the Hardware Parameters, and the Software Parameters.</p>
<p>The Hardware Parameters necessary include the sample rate, the number of channels (stereo or mono), the memory layout of the samples (interleaved or noninterleaved) and the format (16-bit unsigned integer, 32-bit signed, float, etc) of the samples.  It is also necessary to set the period size and number of periods, or equivalently the total buffer size and number of periods.</p>
<h3 id="what-is-the-period-size">What is the period size?</h3>
<p>The period size is the number of samples transferred to an audio device as a unit.   A user program needs to be able to write new samples to a memory area different than that
being transferred, so there must be at least room for <em>at least</em> two periods worth of samples in the buffer. But in some applications it may be useful to size the buffer large enough to hold three or four periods of samples. These parameters are the "period size" and "number of periods."  The total "buffer size" equals the "period size" multiplied by the "number of periods."</p>
<p><img alt="Samples, Periods and Buffer" src="../ask-pcm-figs01/ask-pcm-figs01.001.png" /></p>
<h3 id="how-readers-and-writers-share-the-audio-buffer">How Readers and Writers share the Audio Buffer</h3>
<p>Whether your PCM device is a PLAYBACK or a CAPTURE device, there is a circular buffer between your code and the hardware.  In the case of PLAYBACK, your audio thread is writing samples to the buffer, and the hardware device is reading samples from the buffer.  The figure below illustrates the relationship.</p>
<p><img alt="Samples, Periods and Buffer" src="../ask-pcm-figs01/ask-pcm-figs01.002.png" /></p>
<p>The choice of hardware parameters and your algorithm design must all cooperate for this to work smoothly.  If the software cannot produce new samples at the rate the hardware is consuming them, then a condition known as an "underrun" occurs.   If the software is designed to efficiently produce large chunks of audio, this may reduce the occurrence of underruns, but it can increase the total latency of the system.  Balancing the parameters with the algorithm design of your software is an art in itself.</p>
<h3 id="set-the-hardware-parameters">Set the Hardware Parameters</h3>
<p>The Hardware Parameters are described by an <code>ASKPcmHwParams</code> object.  A HW Params object describes a space of configuration variables that the device might support.  For each of the Hardware Parameters, the <code>ASKPcmHwParams</code> holds a minimum and maximum value that might be satisfied by the device.</p>
<p>To set the Hardware Parameters of a PCM you must first get its <code>ASKPcmHwParams</code> with the following method call.</p>
<p>This object can be inspected by printing it.</p>
<pre><code class="language-objc">   ASKPcmHwParams *hwparams = [pcm getHwParams:&amp;error];
   NSLog(@&quot;%@);
</code></pre>
<p>On our laptop, if we open PCM named "hw:1,0" (the Intel CS4208 Analog device), we see the following output.  For each parameter, the currently selected value is followed by its allowed range in parentheses.  A "U" means the current value is unspecified.</p>
<pre><code class="language-console">2020-12-29 14:17:38.025 miniosc1[104007:104007] ALSA-HWPARAMS chan:U(2,4) rate:U(32000,192000), 
  period:U(8,8192), periods:U(2,32), bufsize:U(16,16384) 
    buftime:U(83,512000) access:&lt;U&gt;:(&quot;MMAP_INTERLEAVED&quot;, &quot;RW_INTERLEAVED&quot;) 
      format:&lt;U&gt;:(&quot;S16_LE&quot;, &quot;S32_LE&quot;)
</code></pre>
<p>This device supports the following Hardware Parameters ranges:</p>
<ul>
<li>it supports from two to four channels</li>
<li>a sample rate between 32000 and 192000 samples per second</li>
<li>a period size of 8 to 8192</li>
<li>the number of periods from 2 to 32</li>
<li>a buffersize from 16 to 16384 (buftime is the bufsize divided by sample rate)</li>
<li>an Interleaved memory access pattern</li>
<li>and signed 16-bit or 32-bit little endian integers</li>
</ul>
<p>That's a lot of information!  And it turns out that many combinations of values allowed by the ranges do not necessarily work.  Very tiny periods stress the CPU beyond what it can deliver.  (Note: if experimenting with your computer, trying a very low period size may hang your system!)  Period sizes that are too large limit the total number of periods.</p>
<p>In any event, one by one, we must set all of these parameters to something allowed.  For instance, we might set the sample rate first to 44100.  </p>
<pre><code class="language-objc">  ok = [pcm setRate:hwparams val:44100 error:&amp;error];
  if (ok == NO) {
    NSLog(@&quot;Error setting rate:%@&quot;, error);
    exit(1);
  }
  NSLog(@&quot;%@&quot;, hwparams);
</code></pre>
<p>If we did, and we printed out the new HW Params object, it would look like the following.  The current value of the rate parameter is 44100 instead of "U".</p>
<pre><code class="language-console">2020-12-29 14:27:54.640 miniosc1[104338:104338] ALSA-HWPARAMS chan:U(2,4) rate:44100(44100,44100), 
  period:U(8,8192), periods:U(2,32), bufsize:U(16,16384) 
    buftime:U(362,371520) access:&lt;U&gt;:(&quot;MMAP_INTERLEAVED&quot;, &quot;RW_INTERLEAVED&quot;) 
      format:&lt;U&gt;:(&quot;S16_LE&quot;, &quot;S32_LE&quot;)
</code></pre>
<p>Our example program <code>examples-ask/miniosc.m</code> shows how to set the Hardware Parameters in turn.  The order our program sets them is this.</p>
<ul>
<li>set sample rate</li>
<li>set number of channels (2)</li>
<li>set access pattern (INTERLEAVED)</li>
<li>set format to S32_LE</li>
<li>set the number of periods as near to 2 as possible</li>
<li>set the period size to 1024 samples</li>
</ul>
<p>Once the <code>ASKPcmHwParams</code> object has been configured, the PCM is set to use these values.</p>
<pre><code class="language-objc">// Now set the HW params
ok = [pcm setHwParams:hwparams error:&amp;error];
if (ok == NO) {
  NSLog(@&quot;Could not set hw params:%@&quot;, error);
  exit(1);
}
</code></pre>
<h3 id="set-the-software-parameters">Set the Software Parameters</h3>
<p>The Software Parameters describe some of the characteristics of how the buffer of samples is transferred to the audio device.  These follow the same pattern of first getting the current Software Paramters, adjusting the values and setting the parameters.  The following works for most devices.</p>
<pre><code class="language-objc">// Set Software Parameters
ASKPcmSwParams *swparams = [pcm getSwParams];

ok = [pcm setAvailMin:swparams val:persize error:&amp;error];
if (ok == NO) {
  NSLog(@&quot;Error setting avail min:%@&quot;, error);
  exit(1);
}

ok = [pcm setStartThreshold:swparams val:0 error:&amp;error];
if (ok == NO) {
  NSLog(@&quot;Error setting start threshold:%@&quot;, error);
  exit(1);
}

ok = [pcm setSwParams:swparams error:&amp;error];
if (ok == NO) {
  NSLog(@&quot;Could not set sw params:%@&quot;, error);
  exit(1);
}
</code></pre>
<p>The <code>ASKPcmSwParams</code> object can be inspected too.  It looks like this for the device we opened earlier.</p>
<pre><code class="language-console">2020-12-29 14:41:47.412 miniosc1[104884:104884] ALSA-SWPARAMS tstampmode:NONE amin:1024 per:0 start:1 stop:2048 sil:0 size:0
</code></pre>
<h2 id="set-the-callbacks">Set the Callbacks</h2>
<p>An <code>ASKPcm</code> manages the audio thread and collects samples for playing (or capturing) through callback blocks.  For a playback PCM, the block is defined with the <code>onPlayback:</code> method.  The block specified must produce one period's worth of frames each time it is called (the parameter <code>nframes</code> will be the period size).</p>
<pre><code class="language-objc">[pcm onPlayback:^(snd_pcm_sframes_t nframes) {
  return (void*) wav;
}];
</code></pre>
<p>The block must return the samples of the period as a <code>void*</code>.  The samples must match the "format" and "access" specified when setting the Hardware parameters.</p>
<p>After the samples are written to the PCM, a second block is called.  This block can be used by user-code for maintenance operations.</p>
<pre><code class="language-objc">[pcm onPlaybackCleanup:^{
    // ... do something after the samples were transferred to the PCM
}]
</code></pre>
<p>There is also a callback block that can receive an error.  The value passed to the block is the ALSA error code.</p>
<pre><code class="language-objc">[pcm onPlaybackThreadError:^(int err) {
  NSLog(@&quot;Got Thread Error:%d&quot;, err);
  exit(1);
}];
</code></pre>
<h3 id="capture-callbacks">Capture Callbacks</h3>
<p>For a capture PCM, there are two callbacks.  The first must return a pointer to a memory area big enough to hold a periods worth of samples.  The second is called after the samples have been written there.</p>
<pre><code class="language-objc">[pcm onCaptureBufferBlock:^{
  return (void*) wav;
}]

[pcm onCapture:^(snd_pcm_sframes_t nframes) {
  // ... handle the frames written to *wav
}]
</code></pre>
<p>There is also a callback block that can receive an error.  The value passed to the block is the ALSA error code.</p>
<pre><code class="language-objc">[pcm onCaptureThreadError:^(int err) {
  NSLog(@&quot;Got Thread Error:%d&quot;, err);
  exit(1);
}];
</code></pre>
<h3 id="an-example-oscilator-a440">An example oscilator: A440</h3>
<p>The example program in <code>examples-ask/miniosc1.m</code> sets up a PCM and plays a SINE-wave note: an A440.  The code setting up the sample buffer and filling it with samples is shown below.  There are some interesting things coded here that point to some of the tedium of working with PCM devices: many of the obtained hardware parameters place requirements on the C code written.</p>
<ul>
<li>the frequency increment (<code>dphi</code>) is a function of sample rate</li>
<li>the size of the data buffer is dependent not only on period size, but sample format (<code>int32_t</code>)</li>
<li>the access pattern (interleaved) is reflected in the loop</li>
</ul>
<pre><code class="language-objc">// Create a waveform: A440
__block double phi = 0;

double dphi = (2 * M_PI) * 440.0 / 22050.0;
NSData *data = [NSMutableData dataWithLength:(2 * persize * sizeof(int32_t))];
int32_t *wav = (int32_t*) [data bytes];

// Install callback
[pcm onPlayback:^(snd_pcm_sframes_t nframes) {
  for (int i = 0; i &lt; 1024; i++) {
    double sound = sin(phi) * (1 &lt;&lt; 24);
    wav[i*2] = sound;
    wav[i*2 + 1] = sound;
    phi += dphi;
    if (phi &gt;= 2*M_PI) {
        phi -= 2*M_PI;
    }
  }
  return (void*) wav;
}];

</code></pre>
<p>The use of the block as a callback lends some conveniences however. The variables and memory buffer used inside the block are "captured" by the compiler.  Without blocks, an equivalent callback function would need more arguments.  Blocks make the callback from the audio thread easier to write.</p>
<h3 id="rules-on-the-callback-blocks">Rules on the Callback Blocks</h3>
<p>The <code>ASKPcm</code> sets up and runs the audio thread.  The callback blocks execute in the context of the audio thread.  You must be very careful about what operations your code performs in these blocks.</p>
<ul>
<li>An operation that could cause the code to "block" can (will!) create audio artifacts!<ul>
<li>Do not perform memory allocation.</li>
<li>Do not read or write files.</li>
<li>Do not use locks.</li>
</ul>
</li>
</ul>
<p>The reason that the blocks are alright is that they are allocated <em>before</em> the audio thread starts playing them.</p>
<p>A great article about some common pitfalls of audio thread programming is this:</p>
<ul>
<li><a href="http://atastypixel.com/blog/four-common-mistakes-in-audio-development/">Four common mistakes in audio development</a> by Michael Tyson</li>
</ul>
<p>Another great article is this one by Ross Bencina:</p>
<ul>
<li><a href="http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing">Real-time audio programming 101: time waits for nothing</a></li>
</ul>
<h2 id="start-the-audio-thread">Start the Audio Thread</h2>
<p>After the <code>ASKPcm</code> is configured and the appropriate callback blocks are set, the PCM can be launched.</p>
<pre><code class="language-objc">// Launch the PCM Thread
ok = [pcm startThreadWithError:&amp;error];
if (ok == NO) {
  NSLog(@&quot;Could not start PCM thread:%@&quot;, error);
  exit(1);
}
</code></pre>
<p>If there is no error, the audio thread will play until stopped.</p>
<h2 id="experiment-with-alsa-devices">Experiment with ALSA Devices</h2>
<p>The example program <code>examples-ask/miniosc1.m</code> is a small program that shows all of the steps necessary to open a PCM device and play a tone. </p>
<p>The program accepts an "device name" as an argument.  Try playing some of the different devices on your system.</p>
<pre><code class="language-console">$ ./miniosc1 default
$ ./miniosc1 hw:1,0
$ ./miniosc1 hw:3,0
</code></pre>
<p>You may find that some devices are silent, or that the parameters do not configure that device appropriately.  See if you can fix the parameters, format size or access to make the device play.</p>
<h2 id="listing-available-pcms">Listing Available PCMs</h2>
<p>The Alsa Sound Kit provides the <code>ASKPcmList</code> utlity class for listing the PCMs in your system.</p>
<pre><code class="language-objc">ASKPcmList *list = [[ASKPcmList alloc] initWithStream:SND_PCM_STREAM_PLAYBACK];
for (ASKPcmListItem *item in list.pcmitems) {
    NSLog(@&quot;device-name:%@ display-name:%@&quot;, 
      item.pcmDeviceName,
      item.pcmDisplayName);
}
</code></pre>
<p>On our system, this produces the following output.</p>
<pre><code class="language-console">2020-12-30 09:17:32.146 askpcmlist[112073:112073] device-name:hw:0,3 display-name:HDMI 0
2020-12-30 09:17:32.146 askpcmlist[112073:112073] device-name:hw:0,7 display-name:HDMI 1
2020-12-30 09:17:32.146 askpcmlist[112073:112073] device-name:hw:0,8 display-name:HDMI 2
2020-12-30 09:17:32.146 askpcmlist[112073:112073] device-name:hw:0,9 display-name:HDMI 3
2020-12-30 09:17:32.146 askpcmlist[112073:112073] device-name:hw:0,10 display-name:HDMI 4
2020-12-30 09:17:32.146 askpcmlist[112073:112073] device-name:hw:1,0 display-name:CS4208 Analog
2020-12-30 09:17:32.146 askpcmlist[112073:112073] device-name:hw:1,1 display-name:CS4208 Digital
2020-12-30 09:17:32.146 askpcmlist[112073:112073] device-name:hw:3,0 display-name:USB Audio
2020-12-30 09:17:32.146 askpcmlist[112073:112073] device-name:default display-name:default
2020-12-30 09:17:32.146 askpcmlist[112073:112073] device-name:null display-name:null
2020-12-30 09:17:32.146 askpcmlist[112073:112073] device-name:pulse display-name:pulse
</code></pre>
<h2 id="summary">Summary</h2>
<p>This chapter described ALSA sound devices called "PCMs".  We gave some examples of how to examine and play the PCMs in your Linux system by using the <code>aplay</code> command.</p>
<p>The Alsa Sound Kit provides an <code>ASKPcm</code> object for interfacing playback and capture PCMs.  It provides methods for configuring the PCM Hardware and Software parameters.  The <code>ASKPcm</code> class also manages the audio thread and recovers from over/underrun conditions, allowing the audio programmer to focus on just the callbacks that provide playback or gather capture data.</p>
<p>The <code>ASKSeq</code> interface is a thin wrapper around the ALSA PCM handle itself.  It does not hide the problems of managing memory and layout for the different access types and format sizes.  For that we will introduce the <code>MSKContext</code> as part of the McLaren Synth Kit in the next chapters.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>(c) McLaren Labs 2024</p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-3.6.0.min.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
